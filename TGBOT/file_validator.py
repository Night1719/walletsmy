"""
Advanced file validation module for detecting screenshots and unwanted content.
"""
import logging
import re
from typing import List, Tuple, Optional
from config import SCREENSHOT_KEYWORDS

logger = logging.getLogger(__name__)

# Additional patterns for detecting screenshot content
SCREENSHOT_PATTERNS = [
    # Common screenshot naming patterns
    r'screenshot_\d{4}-\d{2}-\d{2}',
    r'screen_\d{4}-\d{2}-\d{2}',
    r'capture_\d{4}-\d{2}-\d{2}',
    r'print_screen_\d+',
    r'screen_shot_\d+',
    r'img_\d{4}\d{2}\d{2}',
    r'photo_\d{4}\d{2}\d{2}',
    r'picture_\d{4}\d{2}\d{2}',
    # Russian patterns
    r'скриншот_\d{4}-\d{2}-\d{2}',
    r'экран_\d{4}-\d{2}-\d{2}',
    r'захват_\d{4}-\d{2}-\d{2}',
    r'печать_\d{4}-\d{2}-\d{2}',
    r'фото_\d{4}\d{2}\d{2}',
    r'картинка_\d{4}\d{2}\d{2}',
]

# Common screenshot metadata in files
SCREENSHOT_METADATA_PATTERNS = [
    r'created by screenshot tool',
    r'generated by screen capture',
    r'screenshot software',
    r'print screen',
    r'screen capture',
    r'window capture',
    r'desktop capture',
    r'monitor capture',
    # Russian
    r'создано инструментом скриншота',
    r'сгенерировано захватом экрана',
    r'программное обеспечение скриншота',
    r'печать экрана',
    r'захват экрана',
    r'захват окна',
    r'захват рабочего стола',
    r'захват монитора',
]

# Common screenshot dimensions (width x height)
COMMON_SCREENSHOT_DIMENSIONS = [
    (1920, 1080),  # Full HD
    (1366, 768),   # Common laptop resolution
    (1440, 900),   # MacBook Air
    (1280, 720),   # HD
    (2560, 1440),  # 2K
    (3840, 2160),  # 4K
    (1024, 768),   # Old standard
    (800, 600),    # Very old standard
]


def detect_screenshot_patterns(filename: str) -> List[str]:
    """
    Detect screenshot patterns in filename.
    Returns list of matched patterns.
    """
    matches = []
    filename_lower = filename.lower()
    
    # Check against regex patterns
    for pattern in SCREENSHOT_PATTERNS:
        if re.search(pattern, filename_lower):
            matches.append(f"Filename pattern: {pattern}")
    
    # Check against keyword list
    for keyword in SCREENSHOT_KEYWORDS:
        if keyword in filename_lower:
            matches.append(f"Filename keyword: {keyword}")
    
    return matches


def detect_screenshot_metadata(content: bytes) -> List[str]:
    """
    Detect screenshot-related metadata in file content.
    Returns list of detected patterns.
    """
    matches = []
    
    try:
        # Convert first 2000 bytes to string for analysis
        content_str = content[:2000].decode('utf-8', errors='ignore').lower()
        
        # Check against metadata patterns
        for pattern in SCREENSHOT_METADATA_PATTERNS:
            if re.search(pattern, content_str):
                matches.append(f"Metadata pattern: {pattern}")
        
        # Check for common screenshot software signatures
        software_signatures = [
            'snipping tool',
            'snagit',
            'greenshot',
            'lightshot',
            'picpick',
            'faststone capture',
            'ashampoo snap',
            'hypercam',
            'bandicam',
            'fraps',
            'obs studio',
            'sharex',
            # Russian
            'инструмент ножницы',
            'ножницы',
            'захват экрана',
            'скриншот',
        ]
        
        for signature in software_signatures:
            if signature in content_str:
                matches.append(f"Software signature: {signature}")
    
    except Exception as e:
        logger.warning(f"Error analyzing file metadata: {e}")
    
    return matches


def analyze_file_dimensions(content: bytes) -> List[str]:
    """
    Analyze file dimensions to detect potential screenshots.
    Returns list of dimension-related findings.
    """
    findings = []
    
    try:
        # This is a simplified approach - in practice, you'd need specific
        # parsers for different file formats to extract dimensions
        content_str = content[:1000].decode('utf-8', errors='ignore')
        
        # Look for common dimension patterns in metadata
        dimension_patterns = [
            r'(\d{3,4})\s*[x×]\s*(\d{3,4})',  # 1920x1080, 1920 x 1080, 1920×1080
            r'width[:\s]*(\d{3,4})',          # width: 1920
            r'height[:\s]*(\d{3,4})',         # height: 1080
            r'resolution[:\s]*(\d{3,4})\s*[x×]\s*(\d{3,4})',  # resolution: 1920x1080
        ]
        
        for pattern in dimension_patterns:
            matches = re.findall(pattern, content_str, re.IGNORECASE)
            for match in matches:
                if isinstance(match, tuple):
                    width, height = int(match[0]), int(match[1])
                else:
                    width = int(match)
                    height = 0  # Single dimension found
                
                # Check if dimensions match common screenshot sizes
                if (width, height) in COMMON_SCREENSHOT_DIMENSIONS:
                    findings.append(f"Common screenshot dimensions: {width}x{height}")
                elif width >= 1000 and height >= 600:  # Large dimensions
                    findings.append(f"Large dimensions: {width}x{height}")
    
    except Exception as e:
        logger.warning(f"Error analyzing file dimensions: {e}")
    
    return findings


def comprehensive_screenshot_detection(filename: str, content: bytes) -> Tuple[bool, List[str]]:
    """
    Comprehensive detection of screenshot content.
    Returns (is_screenshot, list_of_reasons)
    """
    reasons = []
    
    # Check filename patterns
    filename_patterns = detect_screenshot_patterns(filename)
    reasons.extend(filename_patterns)
    
    # Check metadata
    metadata_patterns = detect_screenshot_metadata(content)
    reasons.extend(metadata_patterns)
    
    # Check dimensions
    dimension_findings = analyze_file_dimensions(content)
    reasons.extend(dimension_findings)
    
    # Determine if file is likely a screenshot
    is_screenshot = len(reasons) > 0
    
    if is_screenshot:
        logger.info(f"Screenshot detected in {filename}: {reasons}")
    else:
        logger.debug(f"No screenshot patterns detected in {filename}")
    
    return is_screenshot, reasons


def validate_file_safety(filename: str, content: bytes) -> Tuple[bool, str, List[str]]:
    """
    Comprehensive file safety validation.
    Returns (is_safe, reason, detailed_findings)
    """
    findings = []
    
    # Check for screenshot content
    is_screenshot, screenshot_reasons = comprehensive_screenshot_detection(filename, content)
    if is_screenshot:
        findings.extend(screenshot_reasons)
        return False, "File appears to be a screenshot or image", findings
    
    # Additional safety checks can be added here
    # For example: malware detection, content filtering, etc.
    
    return True, "File appears to be safe", findings